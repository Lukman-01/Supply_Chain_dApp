{
  "language": "Solidity",
  "sources": {
    "contracts/YourContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title SupplyChain\n * @dev A smart contract for managing a supply chain system.\n */\ncontract YourContract {\n    uint32 public product_id = 0;  // Tracks the ID of the products in the supply chain\n    uint32 public participant_id = 0;  // Tracks the ID of the participants in the supply chain\n    uint32 public owner_id = 0;  // Tracks the ID of the ownerships in the supply chain\n\n    /**\n     * @dev Struct to store product information.\n     */\n    struct Product {\n        string modelNumber;  // Model number of the product\n        string partNumber;  // Part number of the product\n        string serialNumber;  // Serial number of the product\n        address productOwner;  // Address of the current owner of the product\n        uint32 cost;  // Cost of the product\n        uint32 mfgTimeStamp;  // Manufacturing timestamp of the product\n    }\n\n    /**\n     * @dev Mapping to store products.\n     */\n    mapping(uint32 => Product) public products;  // Associates product IDs with their corresponding Product struct\n\n    /**\n     * @dev Struct to store participant information.\n     */\n    struct Participant {\n        string userName;  // Username of the participant\n        string password;  // Password of the participant\n        string participantType;  // Type of participant (e.g., Manufacturer, Supplier, Consumer)\n        address participantAddress;  // Ethereum address of the participant\n    }\n\n    /**\n     * @dev Mapping to store participants.\n     */\n    mapping(uint32 => Participant) public participants;  // Associates participant IDs with their corresponding Participant struct\n\n    /**\n     * @dev Struct to store ownership information.\n     */\n    struct Ownership {\n        uint32 productId;  // ID of the product\n        uint32 ownerId;  // ID of the owner\n        uint32 trxTimeStamp;  // Timestamp of the ownership transfer\n        address productOwner;  // Address of the current owner of the product\n    }\n\n    /**\n     * @dev Mapping to store ownerships and product track.\n     */\n    mapping(uint32 => Ownership) public ownerships;  // Associates ownership IDs with their corresponding Ownership struct\n    mapping(uint32 => uint32[]) public productTrack;  // Associates product IDs with an array of ownership IDs representing the product's ownership history\n\n    /**\n     * @dev Event to signal ownership transfer.\n     */\n    event TransferOwnership(uint32 productId);  // Event emitted when ownership of a product is transferred\n\n    /**\n     * @dev Function to add a participant to the supply chain.\n     * @param _name The username of the participant.\n     * @param _pass The password of the participant.\n     * @param _pAdd The Ethereum address of the participant.\n     * @param _pType The type of participant (e.g., Manufacturer, Supplier, Consumer).\n     * @return The ID of the newly added participant.\n     */\n    function addParticipant(\n        string memory _name,\n        string memory _pass,\n        address _pAdd,\n        string memory _pType\n    ) public returns (uint32) {\n        uint32 userId = participant_id++;  // Generate new participant ID\n\n        participants[userId] = Participant({\n            userName: _name,\n            password: _pass,\n            participantAddress: _pAdd,\n            participantType: _pType\n        });  // Create a new participant and store their information\n\n        return userId;  // Return the participant ID\n    }\n\n    /**\n     * @dev Function to retrieve participant details.\n     * @param _participant_id The ID of the participant.\n     * @return The username, Ethereum address, and participant type of the participant.\n     */\n    function getParticipant(uint32 _participant_id) public view returns (string memory, address, string memory) {\n        Participant memory p = participants[_participant_id];  // Retrieve the participant based on their ID\n        return (p.userName, p.participantAddress, p.participantType);  // Return the participant details\n    }\n\n    /**\n     * @dev Function to add a product to the supply chain.\n     * @param _ownerId The ID of the participant who is the owner of the product.\n     * @param _modelNumber The model number of the product.\n     * @param _partNumber The part number of the product.\n     * @param _serialNumber The serial number of the product.\n     * @param _productCost The cost of the product.\n     * @return The ID of the newly added product.\n     */\n    function addProduct(\n        uint32 _ownerId,\n        string memory _modelNumber,\n        string memory _partNumber,\n        string memory _serialNumber,\n        uint32 _productCost\n    ) public returns (uint32) {\n        require(\n            keccak256(bytes(participants[_ownerId].participantType)) == keccak256(bytes(\"Manufacturer\")),\n            \"Only a Manufacturer can add a product\"\n        );  // Only a participant with the participant type \"Manufacturer\" can add a product\n\n        uint32 productId = product_id++;  // Generate new product ID\n\n        Product storage p = products[productId];  // Create a new product and store its information\n        p.modelNumber = _modelNumber;\n        p.partNumber = _partNumber;\n        p.serialNumber = _serialNumber;\n        p.cost = _productCost;\n        p.productOwner = participants[_ownerId].participantAddress;\n        p.mfgTimeStamp = uint32(block.timestamp);\n\n        return productId;  // Return the product ID\n    }\n\n    /**\n     * @dev Function to retrieve product details.\n     * @param _productId The ID of the product.\n     * @return The model number, part number, serial number, cost, owner address, and manufacturing timestamp of the product.\n     */\n    function getProduct(uint32 _productId) public view returns (string memory, string memory, string memory, uint32, address, uint32) {\n        Product memory p = products[_productId];  // Retrieve the product based on its ID\n        return (p.modelNumber, p.partNumber, p.serialNumber, p.cost, p.productOwner, p.mfgTimeStamp);  // Return the product details\n    }\n\n    /**\n     * @dev Function to transfer ownership of a product to a new participant.\n     * @param _user1Id The ID of the current owner of the product.\n     * @param _user2Id The ID of the new owner of the product.\n     * @param _prodId The ID of the product to transfer ownership.\n     * @return A boolean indicating whether the ownership transfer was successful.\n     */\n    function newOwner(uint32 _user1Id, uint32 _user2Id, uint32 _prodId) public returns (bool) {\n        require(\n            msg.sender == products[_prodId].productOwner,\n            \"Only the owner can perform this action\"\n        );  // Only the owner of the product can transfer ownership\n\n        Participant memory p1 = participants[_user1Id];  // Retrieve the participants involved in the ownership transfer\n        Participant memory p2 = participants[_user2Id];\n\n        require(\n            keccak256(bytes(p1.participantType)) == keccak256(bytes(\"Manufacturer\")) &&\n            (keccak256(bytes(p2.participantType)) == keccak256(bytes(\"Supplier\")) ||\n            keccak256(bytes(p2.participantType)) == keccak256(bytes(\"Consumer\"))),\n            \"Invalid ownership transfer\"\n        );  // Validate the ownership transfer: The current owner must be a Manufacturer, and the new owner must be a Supplier or Consumer\n\n        uint32 ownership_id = owner_id++;  // Generate a new ownership ID\n\n        ownerships[ownership_id] = Ownership({  // Update ownership information and product owner\n            productId: _prodId,\n            productOwner: p2.participantAddress,\n            ownerId: _user2Id,\n            trxTimeStamp: uint32(block.timestamp)\n        });\n        products[_prodId].productOwner = p2.participantAddress;\n\n        productTrack[_prodId].push(ownership_id);  // Add the ownership ID to the product track\n\n        emit TransferOwnership(_prodId);  // Emit the TransferOwnership event\n\n        return true;  // Return true to indicate a successful ownership transfer\n    }\n\n    /**\n     * @dev Function to retrieve the product track (ownership history) of a product.\n     * @param _prodId The ID of the product.\n     * @return An array of ownership IDs representing the product track.\n     */\n    function getProvenance(uint32 _prodId) public view returns (uint32[] memory) {\n        return productTrack[_prodId];  // Return the array of ownership IDs representing the product track\n    }\n\n    /**\n     * @dev Function to retrieve ownership details.\n     * @param _regId The ID of the ownership.\n     * @return The product ID, owner ID, owner address, and timestamp of the ownership.\n     */\n    function getOwnership(uint32 _regId) public view returns (uint32, uint32, address, uint32) {\n        Ownership memory o = ownerships[_regId];  // Retrieve the ownership based on its ID\n        return (o.productId, o.ownerId, o.productOwner, o.trxTimeStamp);  // Return the ownership details\n    }\n\n    /**\n     * @dev Function to authenticate a participant.\n     * @param _uid The ID of the participant.\n     * @param _uname The username of the participant.\n     * @param _pass The password of the participant.\n     * @param _utype The participant type.\n     * @return A boolean indicating whether the participant is authenticated.\n     */\n    function authenticateParticipant(\n        uint32 _uid,\n        string memory _uname,\n        string memory _pass,\n        string memory _utype\n    ) public view returns (bool) {\n        Participant memory p = participants[_uid];  // Retrieve the participant based on their ID\n\n        // Check if the participant's details match the provided parameters\n        return (\n            keccak256(bytes(p.participantType)) == keccak256(bytes(_utype)) &&\n            keccak256(bytes(p.userName)) == keccak256(bytes(_uname)) &&\n            keccak256(bytes(p.password)) == keccak256(bytes(_pass))\n        );\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}